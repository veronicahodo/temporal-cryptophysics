# Rhex Format Specification

The R⬢ ("Rhex") is the atomic unit of signed, append-only truth in Temporal Cryptophysics. This document defines its structure, field expectations, and canonical behavior.

---

## 📦 Overview

A Rhex is a JSON object with a strict schema and deterministic signature rules. It is:

-   Append-only
-   Cryptographically signed
-   Self-contained
-   Canonically hashed

Rhex records form a linked chain via `previous_hash`, producing a time-anchored, immutable ledger.

---

## 🧱 Core Fields

Each R⬢ must contain the following fields:

```json
{
  "previous_hash": "...",       // base64 of prior R⬢'s hash or null for genesis
  "protocol": "v1",             // current protocol version string
  "scope": "root.branch.leaf",  // root→leaf hierarchical name
  "nonce": "...",               // cryptographically random value
  "at": 1293.2002022,           // GT timestamp (float)
  "record_type": "...",         // e.g. "key:grant", "policy:set", "note"
  "data": { ... },              // arbitrary, schema-defined object
  "signatures":                 // one or more authorized signatures
    {
      "key": "...",             // base64 public key
      "type": "owner|quorum",   // role in policy
      "signature": "..."        // base64 signature of canonical payload
    }
  ],
  "current_hash": "..."         // base64 hash of all canonical fields
}
```

---

## 🛡️ Canonical Signing Payload

The signature payload MUST be generated by:

1. Selecting canonical fields: `previous_hash`, `protocol`, `scope`, `nonce`, `at`, `record_type`, `data`
2. Canonicalizing to JSON using [RFC 8785](https://www.rfc-editor.org/rfc/rfc8785.html)
3. Signing the canonical string with the ed25519 private key

---

## 🔄 Hashing

The `current_hash` is:

-   A base64-encoded SHA3-256 hash of the canonicalized object

The `previous_hash` field must match the `current_hash` of the immediately prior R⬢ in the chain.

---

## 🔐 Signature Array

Each entry in `signatures[]` must:

-   Contain a `key` that was granted via `key:grant` within the declared `scope`
-   Follow `policy:set` rules if quorum is required
-   Use ed25519 signature over the canonical payload

Multiple signatures may exist:

-   `owner` → a single authoritative signer
-   `quorum` → additional required signers per policy

---

## 🎯 Record Type Conventions

| `record_type`  | Purpose                         |
| -------------- | ------------------------------- |
| `key:grant`    | Authorizes a key in a scope     |
| `key:revoke`   | Revokes an existing key         |
| `policy:set`   | Sets quorum/signature rules     |
| `scope:create` | Initializes a new scope         |
| `note`         | Arbitrary, signed data blob     |
| `alias:set`    | Maps a readable name to a scope |
| `heartbeat`    | Periodic time-anchor            |

Others are allowed but must be documented under `data.schema`.

---

## 🧬 Sample Minimal Record

```json
{
    "previous_hash": null,
    "protocol": "v1",
    "scope": "root",
    "nonce": "d9xN...",
    "at": 0.0,
    "record_type": "scope:create",
    "data": { "schema": "scope_create_r1" },
    "signatures": [
        {
            "key": "A1bC...",
            "type": "owner",
            "signature": "MEUC..."
        }
    ],
    "current_hash": "qTqE..."
}
```

---

## 📌 Implementation Notes

-   The field order MUST NOT matter during parsing, but MUST be canonicalized for signing and hashing
-   `signatures` should be validated against the latest known `key:grant` and `policy:set` for the scope
-   Record validation is recursive: hash, signature, scope, grant chain
-   Genesis is the only record with `previous_hash: null`

---

> If you can parse this, you can build a ledger.
